from __future__ import annotations

import os
from pathlib import Path
from typing import *

import numpy as np
import pandas as pd
import pyproj
import shapely.wkt
import skimage
from affine import Affine
from pandas import Series
from rasterio import features

from tile2net.raster.tile_utils.geodata_utils import _check_skimage_im_load
from .fixed import GeoDataFrameFixed

pd.options.mode.chained_assignment = None
os.environ['USE_PYGEOS'] = '0'
import geopandas as gpd
import shapely


class Mask2Poly(
    GeoDataFrameFixed,
):
    @classmethod
    def from_path(
            cls,
            path: str | Path,
            affine: Affine,
            crs: str | pyproj.CRS = "EPSG:3857",
            **label2id: dict[str, int]
    ) -> Self:
        array = skimage.io.imread(str(path))
        return cls.from_array(array, affine, crs=crs, **label2id)

    @classmethod
    def from_array(
            cls,
            array: np.ndarray,
            affine: Affine,
            crs: str | pyproj.CRS = "EPSG:3857",
            **label2id: dict[str, int]
    ) -> Self:
        ARRAY = array
        concat: list[gpd.GeoDataFrame] = []
        for label, id in label2id.items():
            array = ARRAY[:, :, id]
            if not array.max() > 0:
                continue
            frame = (
                cls
                .mask_to_poly_geojson(array, affine)
                .assign(f_type=label)
            )
            concat.append(frame)

        result = (
            pd.concat(concat)
            .pipe(cls)
            .set_crs(crs, allow_override=True)
        )
        if result.empty:
            result.columns = 'geometry value f_type'.split()

        return result

    @classmethod
    def mask_to_poly_geojson(
            cls,
            pred_arr,
            transform: Affine,
            channel_scaling=None,
            bg_threshold=0,
    ) -> Self:
        source = cls.preds_to_binary(pred_arr, channel_scaling, bg_threshold)

        mask = source > bg_threshold
        mask = mask.astype('uint8')

        polygon_generator = features.shapes(
            source=source,
            mask=mask,
            transform=transform,
        )
        data = polygon_generator
        columns = 'geometry value'.split()
        result = cls.from_records(data, columns=columns)

        return result

    @classmethod
    def preds_to_binary(
            cls,
            pred_arr: Union[np.ndarray, str],
            channel_scaling=None,
            bg_threshold=0
    ) -> np.ndarray:
        """
        *Adopted from the Solaris library to overcome dependency issues*

        Convert a set of predictions from a neural net to a binary mask.

        Parameters
        ----------
        pred_arr : :class:`numpy.ndarray`
            A set of predictions generated by a neural net (generally in ``float``
            dtype). This can be a 2D array or a 3D array, in which case it will
            be convered to a 2D mask output with optional channel scaling (see
            the `channel_scaling` argument). If a filename is provided instead of
            an array, the image will be loaded using scikit-image.
        channel_scaling : `list`-like of `float`s, optional
            If `pred_arr` is a 3D array, this argument defines how each channel
            will be combined to generate a binary output. channel_scaling should
            be a `list`-like of length equal to the number of channels in
            `pred_arr`. The following operation will be performed to convert the
            multi-channel prediction to a 2D output ::

                sum(pred_arr[channel]*channel_scaling[channel])

            If not provided, no scaling will be performend and channels will be
            summed.

        bg_threshold : `int` or `float`, optional
            The cutoff to set to distinguish between background and foreground
            pixels in the final binary mask. Binarization takes place *after*
            channel scaling and summation (if applicable). Defaults to 0.

        Returns
        -------
        mask_arr : :class:`numpy.ndarray`
            A 2D boolean ``numpy`` array with ``True`` for foreground pixels and
            ``False`` for background.
        """
        pred_arr = _check_skimage_im_load(pred_arr).copy()

        if len(pred_arr.shape) == 3:
            if pred_arr.shape[0] < pred_arr.shape[-1]:
                pred_arr = np.moveaxis(pred_arr, 0, -1)
            if channel_scaling is None:  # if scale values weren't provided
                channel_scaling = np.ones(
                    shape=(pred_arr.shape[-1]),
                    dtype='float'
                )
            pred_arr = np.sum(pred_arr * np.array(channel_scaling), axis=-1)

        mask_arr = (
                pred_arr
                .__gt__(bg_threshold)
                .astype('uint8')
                * 255
        )
        return mask_arr

    # def _sanitize(
    #         self,
    #         simplify: float = 0.8,
    #         min_area: float = 20,
    # ) -> Self:
    #     result = (
    #         self
    #         .buffer(0.)
    #         .make_valid()
    #     )
    #     if min_area:
    #         loc = result.area >= min_area
    #         result = result[loc]
    #     if simplify:
    #         result = result.simplify(tolerance=simplify)
    #     result = self.__class__(result)
    #     return result

    def _replace_convexhull(
            self,
            convex=0.8
    ) -> Self:
        """
        replace the convex polygons with their envelopes
        Args:
            self: geopandas geodataframe
            convex:: convexity threshold to filter lines

        Returns:
            geopandas geodataframe
        """
        hulls: gpd.GeoSeries = self.convex_hull
        convexity = self.area / hulls.area
        loc = convexity > convex
        hulls = hulls.loc[loc]
        result: gpd.GeoDataFrame = self.copy()
        result.update(hulls)
        return result

    def _fill_holes(
            self,
            max_area: float,
    ) -> Self:
        """
        finds holes in the polygons
        Parameters
        ----------
        gs: gpd.GeoSeries
            the GeoSeries of Shapely Polygons to be filled
        max_area: int
            maximum area of holes to be filled

        Returns
        -------
        newgeom: list[shapely.geometry.Polygon]
            list of polygons with holes filled
        """
        RINGS = shapely.get_rings(self)
        area = shapely.area(RINGS)
        repeat = shapely.get_num_interior_rings(self) + 1
        indices = np.arange(len(repeat)).repeat(repeat)
        loc = area >= max_area
        loc |= (
                pd.Series(indices)
                .groupby(indices, sort=False)
                .cumcount()
                == 0
        )
        rings = RINGS[loc]
        indices = indices[loc]
        data = shapely.polygons(rings, indices=indices)
        index = self.index[loc]
        geometry = gpd.GeoSeries(data, index=index, crs=self.crs)
        result = self.set_geometry(geometry).pipe(self.__class__)
        return result

    def postprocess(
            self,
            max_ring_area: Union[
                float,
                Series
            ] = None,
            grid_size: int = None,
            min_polygon_area: Union[
                float,
                Series
            ] = 20,
            convexity: Union[
                float,
                Series
            ] = 0.8,
            simplify: Union[
                float,
                Series
            ] = 0.8,
    ) -> gpd.GeoDataFrame:
        # todo: we need to map feature to max ring area
        cls = self.__class__
        result = self
        if min_polygon_area is not None:
            loc = result.area >= min_polygon_area
            result = result.loc[loc]
        if simplify is not None:
            result = result.simplify(tolerance=simplify)
        if grid_size is not None:
            # mary-h86 your code originally used np.round  but
            #   this is better because it avoids degenerate geoms?
            # todo: precision is int but set_precision expects grid_size
            result = result.set_precision(grid_size=grid_size)
        if max_ring_area is not None:
            result = cls._fill_holes(result, max_ring_area)
        if convexity is not None:
            result = cls._replace_convexhull(result, convex=convexity)

        return result
