from __future__ import annotations
from tile2net.logger import logger

import os
from pathlib import Path
from typing import *

import numpy as np
import pandas as pd
import pyproj
import shapely.wkt
import skimage
from affine import Affine
from pandas import Series
from rasterio import features
import tile2net.tiles.stitched

import tile2net.raster.tile
import tile2net.raster.tile_utils.topology
import tile2net.tileseg.utils.misc
from tile2net.raster.tile_utils.geodata_utils import _check_skimage_im_load
from tile2net.tiles.util import look_at
from .fixed import GeoDataFrameFixed

from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
import geopandas as gpd
import pandas as pd

import geopandas as gpd
import shapely
from .cfg import cfg

os.environ['USE_PYGEOS'] = '0'


class Mask2Poly(
    GeoDataFrameFixed,
):

    @classmethod
    def from_path(
            cls,
            path: str | Path,
            affine: Affine,
            crs: str | pyproj.CRS = "EPSG:3857",
    ) -> Self:
        array = skimage.io.imread(str(path))
        return cls.from_array(array, affine, crs=crs)

    @classmethod
    def from_parquets(
            cls,
            files: Iterable[str | Path],
            *,
            threads: int | None = None,
            **read_parquet_kwargs,
    ) -> Self:
        paths = [str(Path(p)) for p in files]
        if not paths:
            return cls()
        msg = f'Reading {len(paths)} parquet files into {cls.__name__}'
        logger.debug(msg)

        def _load(fp: str):
            return gpd.read_parquet(fp, **read_parquet_kwargs)

        max_workers = threads or min(32, len(paths))
        with ThreadPoolExecutor(max_workers=max_workers) as pool:
            frames = list(pool.map(_load, paths))

        result = (
            pd.concat(frames, ignore_index=True)
            .pipe(cls, geometry='geometry', crs=frames[0].crs)
        )
        return result

    @classmethod
    @look_at(tile2net.tiles.stitched.Stitched.affine_params)
    def from_array(
            cls,
            array: np.ndarray,
            affine: Affine,
            crs: str | pyproj.CRS = "EPSG:3857",
    ) -> Self:
        # todo: check over where the crs whould be what, and to support user input
        """
        array:
            raw prediction array
        affine:
            affine transformation for tile
        crs:
            CRS of the output GeoDataFrame
        label2id:
            f_type label to channel id mapping e.g. {'road': 0, 'sidewalk': 1, ...}
        """
        ARRAY = array
        concat: list[gpd.GeoDataFrame] = []
        label2id = cfg.label2id
        for label, id in label2id.items():
            array = ARRAY[:, :, id]
            if not array.max() > 0:
                continue
            frame = (
                cls
                .mask_to_poly_geojson(array, affine)
                .assign(f_type=label)
            )
            concat.append(frame)

        result = (
            pd.concat(concat)
            .pipe(cls)
            .set_crs(crs, allow_override=True)
        )
        if result.empty:
            result.columns = 'geometry value f_type'.split()

        return result

    @classmethod
    @look_at(tile2net.raster.tile.Tile.mask_to_poly_geojson)
    def mask_to_poly_geojson(
            cls,
            pred_arr,
            transform: Affine,
            channel_scaling=None,
            bg_threshold=0,
    ) -> Self:
        source = cls.preds_to_binary(pred_arr, channel_scaling, bg_threshold)

        mask = source > bg_threshold
        mask = mask.astype('uint8')

        polygon_generator = features.shapes(
            source=source,
            mask=mask,
            transform=transform,
        )
        data = polygon_generator
        columns = 'geometry value'.split()
        result = cls.from_records(data, columns=columns)

        return result

    @classmethod
    @look_at(tile2net.raster.tile.Tile.preds_to_binary)
    def preds_to_binary(
            cls,
            pred_arr: Union[np.ndarray, str],
            channel_scaling=None,
            bg_threshold=0
    ) -> np.ndarray:
        """
        *Adopted from the Solaris library to overcome dependency issues*

        Convert a set of predictions from a neural net to a binary mask.

        Parameters
        ----------
        pred_arr : :class:`numpy.ndarray`
            A set of predictions generated by a neural net (generally in ``float``
            dtype). This can be a 2D array or a 3D array, in which case it will
            be convered to a 2D mask output with optional channel scaling (see
            the `channel_scaling` argument). If a filename is provided instead of
            an array, the image will be loaded using scikit-image.
        channel_scaling : `list`-like of `float`s, optional
            If `pred_arr` is a 3D array, this argument defines how each channel
            will be combined to generate a binary output. channel_scaling should
            be a `list`-like of length equal to the number of channels in
            `pred_arr`. The following operation will be performed to convert the
            multi-channel prediction to a 2D output ::

                sum(pred_arr[channel]*channel_scaling[channel])

            If not provided, no scaling will be performend and channels will be
            summed.

        bg_threshold : `int` or `float`, optional
            The cutoff to set to distinguish between background and foreground
            pixels in the final binary mask. Binarization takes place *after*
            channel scaling and summation (if applicable). Defaults to 0.

        Returns
        -------
        mask_arr : :class:`numpy.ndarray`
            A 2D boolean ``numpy`` array with ``True`` for foreground pixels and
            ``False`` for background.
        """
        pred_arr = _check_skimage_im_load(pred_arr).copy()

        if len(pred_arr.shape) == 3:
            if pred_arr.shape[0] < pred_arr.shape[-1]:
                pred_arr = np.moveaxis(pred_arr, 0, -1)
            if channel_scaling is None:  # if scale values weren't provided
                channel_scaling = np.ones(
                    shape=(pred_arr.shape[-1]),
                    dtype='float'
                )
            pred_arr = np.sum(pred_arr * np.array(channel_scaling), axis=-1)

        mask_arr = (
                pred_arr
                .__gt__(bg_threshold)
                .astype('uint8')
                * 255
        )
        return mask_arr

    @look_at(tile2net.raster.tile_utils.topology.replace_convexhull)
    def _replace_convexhull(
            self,
            threshold: float | Series
    ) -> Self:
        """
        replace the convex polygons with their envelopes
        Args:
            self: geopandas geodataframe
            threshold: convexity threshold to filter lines

        Returns:
            geopandas geodataframe
        """
        hulls: gpd.GeoSeries = self.convex_hull
        convexity = self.area / hulls.area  # [0, 1]
        loc = convexity > threshold
        hulls = hulls.loc[loc]
        result: gpd.GeoDataFrame = self.copy()
        result.update(hulls)
        return result

    @look_at(tile2net.raster.tile_utils.topology.fill_holes)
    def _fill_holes(
            self,
            max_area: float | Series,
    ) -> Self:
        """
        finds holes in the polygons
        Parameters
        ----------
        gs: gpd.GeoSeries
            the GeoSeries of Shapely Polygons to be filled
        max_area: int
            maximum area of holes to be filled

        Returns
        -------
        newgeom: list[shapely.geometry.Polygon]
            list of polygons with holes filled
        """
        RINGS = shapely.get_rings(self)
        area = shapely.area(RINGS)
        repeat = shapely.get_num_interior_rings(self) + 1
        indices = np.arange(len(repeat)).repeat(repeat)
        loc = area >= max_area
        # always keep exteriors
        loc |= (
                pd.Series(indices)
                .groupby(indices, sort=False)
                .cumcount()
                == 0
        )
        rings = RINGS[loc]
        indices = indices[loc]
        data = shapely.polygons(rings, indices=indices)
        index = self.index[loc]
        geometry = gpd.GeoSeries(data, index=index, crs=self.crs)
        result = self.set_geometry(geometry).pipe(self.__class__)
        return result

    @look_at(tile2net.raster.tile.Tile.mask2poly)
    def postprocess(
            self,
            min_poly_area: Union[float, Series, dict] = None,
            simplify: Union[float, Series, dict] = None,
            grid_size: Union[float, Series, dict] = None,
            max_hole_area: Union[float, Series, dict] = None,
            convexity: Union[float, Series, dict] = None,
    ) -> Self:
        cls = self.__class__
        result = self

        if min_poly_area is None:
            min_poly_area = cfg.polygon.min_polygon_area
        if simplify is None:
            simplify = cfg.polygon.simplify
        if grid_size is None:
            grid_size = cfg.polygon.grid_size
        if max_hole_area is None:
            max_hole_area = cfg.polygon.max_hole_area
        if convexity is None:
            convexity = cfg.polygon.convexity

        if isinstance(min_poly_area, dict):
            min_poly_area = (
                pd.Series(min_poly_area)
                .reindex(result.f_type, fill_value=0.0)
                .values
            )

        if isinstance(simplify, dict):
            simplify = (
                pd.Series(simplify)
                .reindex(result.f_type, fill_value=0.0)
                .values
            )

        if isinstance(max_hole_area, dict):
            max_hole_area = (
                pd.Series(max_hole_area)
                .reindex(result.f_type, fill_value=0.)
                .values
            )

        if isinstance(convexity, dict):
            convexity = (
                pd.Series(convexity)
                .reindex(result.f_type, fill_value=1.)
                .values
            )

        min_poly_area: Union[float, Series]
        simplify: Union[float, Series]
        max_hole_area: Union[float, Series]
        convexity: Union[float, Series]

        # todo: avoid unnecessarily computing area, etc for redundant parameters
        if min_poly_area is not None:
            loc = result.area >= min_poly_area
            result = result.loc[loc]
        if simplify is not None:
            result = result.simplify(tolerance=simplify)
        if grid_size is not None:
            result = result.set_precision(grid_size=grid_size)
        if max_hole_area is not None:
            result = cls._fill_holes(result, max_area=max_hole_area)
        if convexity is not None:
            result = cls._replace_convexhull(result, convex=convexity)

        return result
