from __future__ import annotations

import os
from pathlib import Path
from typing import *

import numpy as np
import pandas as pd
import pyproj
import shapely.wkt
import skimage
from affine import Affine
from pandas import Series
from rasterio import features
import tile2net.tiles.stitched

import tile2net.raster.tile
import tile2net.raster.tile_utils.topology
import tile2net.tileseg.utils.misc
from tile2net.raster.tile_utils.geodata_utils import _check_skimage_im_load
from tile2net.tiles.util import look_at
from .fixed import GeoDataFrameFixed

pd.options.mode.chained_assignment = None
os.environ['USE_PYGEOS'] = '0'
import geopandas as gpd
import shapely


class Mask2Poly(
    GeoDataFrameFixed,
):
    @classmethod
    def from_path(
            cls,
            path: str | Path,
            affine: Affine,
            crs: str | pyproj.CRS = "EPSG:3857",
            **label2id: dict[str, int]
    ) -> Self:
        array = skimage.io.imread(str(path))
        return cls.from_array(array, affine, crs=crs, **label2id)

    @classmethod
    @look_at(tile2net.tiles.stitched.Stitched.affine_params)
    def from_array(
            cls,
            array: np.ndarray,
            affine: Affine,
            crs: str | pyproj.CRS = "EPSG:3857",
            **label2id: dict[str, int]
    ) -> Self:
        # todo: check over where the crs whould be what, and to support user input
        """
        array:
            raw prediction array
        affine:
            affine transformation for tile
        crs:
            CRS of the output GeoDataFrame
        label2id:
            f_type label to channel id mapping e.g. {'road': 0, 'sidewalk': 1, ...}
        """
        ARRAY = array
        concat: list[gpd.GeoDataFrame] = []
        for label, id in label2id.items():
            array = ARRAY[:, :, id]
            if not array.max() > 0:
                continue
            frame = (
                cls
                .mask_to_poly_geojson(array, affine)
                .assign(f_type=label)
            )
            concat.append(frame)

        result = (
            pd.concat(concat)
            .pipe(cls)
            .set_crs(crs, allow_override=True)
        )
        if result.empty:
            result.columns = 'geometry value f_type'.split()

        return result

    @classmethod
    @look_at(tile2net.raster.tile.Tile.mask_to_poly_geojson)
    def mask_to_poly_geojson(
            cls,
            pred_arr,
            transform: Affine,
            channel_scaling=None,
            bg_threshold=0,
    ) -> Self:
        source = cls.preds_to_binary(pred_arr, channel_scaling, bg_threshold)

        mask = source > bg_threshold
        mask = mask.astype('uint8')

        polygon_generator = features.shapes(
            source=source,
            mask=mask,
            transform=transform,
        )
        data = polygon_generator
        columns = 'geometry value'.split()
        result = cls.from_records(data, columns=columns)

        return result

    @classmethod
    @look_at(tile2net.raster.tile.Tile.preds_to_binary)
    def preds_to_binary(
            cls,
            pred_arr: Union[np.ndarray, str],
            channel_scaling=None,
            bg_threshold=0
    ) -> np.ndarray:
        """
        *Adopted from the Solaris library to overcome dependency issues*

        Convert a set of predictions from a neural net to a binary mask.

        Parameters
        ----------
        pred_arr : :class:`numpy.ndarray`
            A set of predictions generated by a neural net (generally in ``float``
            dtype). This can be a 2D array or a 3D array, in which case it will
            be convered to a 2D mask output with optional channel scaling (see
            the `channel_scaling` argument). If a filename is provided instead of
            an array, the image will be loaded using scikit-image.
        channel_scaling : `list`-like of `float`s, optional
            If `pred_arr` is a 3D array, this argument defines how each channel
            will be combined to generate a binary output. channel_scaling should
            be a `list`-like of length equal to the number of channels in
            `pred_arr`. The following operation will be performed to convert the
            multi-channel prediction to a 2D output ::

                sum(pred_arr[channel]*channel_scaling[channel])

            If not provided, no scaling will be performend and channels will be
            summed.

        bg_threshold : `int` or `float`, optional
            The cutoff to set to distinguish between background and foreground
            pixels in the final binary mask. Binarization takes place *after*
            channel scaling and summation (if applicable). Defaults to 0.

        Returns
        -------
        mask_arr : :class:`numpy.ndarray`
            A 2D boolean ``numpy`` array with ``True`` for foreground pixels and
            ``False`` for background.
        """
        pred_arr = _check_skimage_im_load(pred_arr).copy()

        if len(pred_arr.shape) == 3:
            if pred_arr.shape[0] < pred_arr.shape[-1]:
                pred_arr = np.moveaxis(pred_arr, 0, -1)
            if channel_scaling is None:  # if scale values weren't provided
                channel_scaling = np.ones(
                    shape=(pred_arr.shape[-1]),
                    dtype='float'
                )
            pred_arr = np.sum(pred_arr * np.array(channel_scaling), axis=-1)

        mask_arr = (
                pred_arr
                .__gt__(bg_threshold)
                .astype('uint8')
                * 255
        )
        return mask_arr


    @look_at(tile2net.raster.tile_utils.topology.replace_convexhull)
    def _replace_convexhull(
            self,
            convex=0.8
    ) -> Self:
        """
        replace the convex polygons with their envelopes
        Args:
            self: geopandas geodataframe
            convex:: convexity threshold to filter lines

        Returns:
            geopandas geodataframe
        """
        hulls: gpd.GeoSeries = self.convex_hull
        convexity = self.area / hulls.area
        loc = convexity > convex
        hulls = hulls.loc[loc]
        result: gpd.GeoDataFrame = self.copy()
        result.update(hulls)
        return result

    @look_at(tile2net.raster.tile_utils.topology.fill_holes)
    def _fill_holes(
            self,
            max_area: float,
    ) -> Self:
        """
        finds holes in the polygons
        Parameters
        ----------
        gs: gpd.GeoSeries
            the GeoSeries of Shapely Polygons to be filled
        max_area: int
            maximum area of holes to be filled

        Returns
        -------
        newgeom: list[shapely.geometry.Polygon]
            list of polygons with holes filled
        """
        RINGS = shapely.get_rings(self)
        area = shapely.area(RINGS)
        repeat = shapely.get_num_interior_rings(self) + 1
        indices = np.arange(len(repeat)).repeat(repeat)
        loc = area >= max_area
        # always keep exteriors
        loc |= (
                pd.Series(indices)
                .groupby(indices, sort=False)
                .cumcount()
                == 0
        )
        rings = RINGS[loc]
        indices = indices[loc]
        data = shapely.polygons(rings, indices=indices)
        index = self.index[loc]
        geometry = gpd.GeoSeries(data, index=index, crs=self.crs)
        result = self.set_geometry(geometry).pipe(self.__class__)
        return result

    @look_at(tile2net.raster.tile.Tile.mask2poly)
    def postprocess(
            self,
            max_ring_area: Union[
                float,
                Series
            ] = None,
            grid_size: int = None,
            min_polygon_area: Union[
                float,
                Series
            ] = 20,
            convexity: Union[
                float,
                Series
            ] = 0.8,
            simplify: Union[
                float,
                Series
            ] = 0.8,
    ) -> gpd.GeoDataFrame:
        # todo: use will be able to pass dict such as
        # min_ring_area=dict(road=30, crosswalk=15, sidewalk=None)
        # todo: plan is to concatenate all tile gdfs, then postprocess

        # todo: we need to map feature to max ring area
        cls = self.__class__
        result = self
        if min_polygon_area is not None:
            loc = result.area >= min_polygon_area
            result = result.loc[loc]
        if simplify is not None:
            result = result.simplify(tolerance=simplify)
        if grid_size is not None:
            # @maryam your code originally used np.round  but
            #   this is better because it avoids degenerate geoms?
            # todo: precision  is int but set_precision expects grid_size
            result = result.set_precision(grid_size=grid_size)
        if max_ring_area is not None:
            result = cls._fill_holes(result, max_ring_area)
        if convexity is not None:
            result = cls._replace_convexhull(result, convex=convexity)

        return result
