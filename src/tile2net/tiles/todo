with logging_redirect_tqdm():
    for i, (input_images, labels, img_names, scale_float) in enumerate(tqdm(loader)):
        if i % 20 == 0:
            logger.debug(f'Inference [Iter: {i + 1} / {len(loader)}]')

Tiles

SourceTiles
    - stitch to inference tiles aggregates source tiles
InferenceTiles
    - stitch to network tiles aggregates inference tiles
    - does not write polygons
NetworkTiles
    - generates polygons for each network tile
    - from polygons creates network tiles
    - each tile is a separate multiprocessing worker

source -> inference -> network

SourceTiles.stitch() -> InferenceTiles
InferenceTiles.stitch() -> NetworkTiles

pad.

InTiles.stitch() -> PredTiles
PredTiles.stitch() -> OutTiles

previously, mosaic.xtile and mosaic.ytile were easy because they were 1-to-1 mappings and therefore columns
now, each xtile and ytile can belong to two mosaics

can't use mosaic(frame) because we need to first access lengt,


pred.xtile
out.xtile


padded inherits from

each tile subclass should get its own self.static so it can get self.static.black

predict.py
mask2poly.py
minibatch.py